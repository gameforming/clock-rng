<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Clock Factory Tycoon</title>
  <style>
    body { font-family: sans-serif; display: flex; }
    canvas { border: 1px solid #000; }
    #sidebar { margin-left: 10px; }
    button { margin: 5px 0; }
  </style>
</head>
<body>
  <canvas id="game" width="512" height="512"></canvas>
  <div id="sidebar">
    <h3>Shop</h3>
    <button onclick="selectBlock('factory')">Factory</button>
    <button onclick="selectBlock('sell')">Sell</button>
    <button onclick="selectBlock('+2')">+2</button>
    <button onclick="selectBlock('x2')">x2</button>
    <button onclick="selectBlock('turn-left')">Turn Left</button>
    <button onclick="selectBlock('turn-right')">Turn Right</button>
    <br>
    <button onclick="goHome()">Back to homepage</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const gridSize = 32;
    const gridWidth = 16;
    const gridHeight = 16;

    let selectedBlock = null;
    const grid = Array.from({ length: gridHeight }, () => Array(gridWidth).fill(null));
    const factories = [];
    const clocks = [];

    function selectBlock(type) {
      selectedBlock = type;
    }

    function goHome() {
      window.location.href = 'index.html';
    }

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / gridSize);
      const y = Math.floor((e.clientY - rect.top) / gridSize);
      if (selectedBlock) {
        grid[y][x] = selectedBlock;
        if (selectedBlock === 'factory') {
          factories.push({ x, y });
        }
      }
    });

    function spawnClocks() {
      factories.forEach(f => {
        clocks.push({ x: f.x, y: f.y, dir: 'right' });
      });
    }

    function updateClocks() {
      clocks.forEach(clock => {
        const block = grid[clock.y]?.[clock.x];
        if (block === 'turn-left') {
          if (clock.dir === 'right') clock.dir = 'up';
          else if (clock.dir === 'down') clock.dir = 'left';
          else if (clock.dir === 'left') clock.dir = 'down';
          else if (clock.dir === 'up') clock.dir = 'right';
        } else if (block === 'turn-right') {
          if (clock.dir === 'up') clock.dir = 'right';
          else if (clock.dir === 'right') clock.dir = 'down';
          else if (clock.dir === 'down') clock.dir = 'left';
          else if (clock.dir === 'left') clock.dir = 'up';
        }

        if (clock.dir === 'right') clock.x++;
        else if (clock.dir === 'left') clock.x--;
        else if (clock.dir === 'up') clock.y--;
        else if (clock.dir === 'down') clock.y++;
      });
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          ctx.strokeStyle = '#aaa';
          ctx.strokeRect(x * gridSize, y * gridSize, gridSize, gridSize);

          const block = grid[y][x];
          if (block) {
            ctx.fillStyle = block === 'factory' ? 'gray'
                           : block === 'sell' ? 'green'
                           : block === '+2' ? 'orange'
                           : block === 'x2' ? 'blue'
                           : block === 'turn-left' ? 'purple'
                           : block === 'turn-right' ? 'pink'
                           : 'white';
            ctx.fillRect(x * gridSize + 4, y * gridSize + 4, gridSize - 8, gridSize - 8);
          }
        }
      }

      clocks.forEach(clock => {
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(clock.x * gridSize + gridSize / 2, clock.y * gridSize + gridSize / 2, 8, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    setInterval(() => {
      spawnClocks();
      updateClocks();
      draw();
    }, 1000);
  </script>
</body>
</html>
