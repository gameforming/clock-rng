<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Minesell 2D Minecraft - Demo</title>
<style>
  body {
    margin: 0; background: #87ceeb; overflow: hidden; font-family: sans-serif;
  }
  canvas {
    display: block; background: #87ceeb; margin: auto; border: 1px solid black;
  }
  #inventory {
    position: fixed;
    top: 50px; left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.8);
    color: white;
    padding: 20px;
    display: none;
    border-radius: 10px;
  }
  #inventory h2 {
    margin-top: 0;
  }
  .item-slot {
    width: 40px; height: 40px;
    border: 1px solid white;
    display: inline-block;
    margin: 5px;
    vertical-align: top;
    text-align: center;
    line-height: 40px;
    font-weight: bold;
    user-select: none;
  }
</style>
</head>
<body>

<canvas id="gameCanvas" width="640" height="480"></canvas>

<div id="inventory">
  <h2>Inventory (Press E to close)</h2>
  <div id="inventorySlots"></div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const tileSize = 32;
const worldWidth = 50;
const worldHeight = 20;

// Define block types and colors
const BLOCKS = {
  air: {color: '#87ceeb', walkable: true},
  grass: {color: '#00cc00', walkable: false},
  stone: {color: '#888888', walkable: false},
  wood: {color: '#8b4513', walkable: true}, // player can pass wood
  leaves: {color: '#228B22', walkable: true},
  iron: {color: '#d8d8d8', walkable: false},
  gold: {color: '#ffd700', walkable: false},
  diamond: {color: '#00ffff', walkable: false}
};

// Simple world 2D array: generate ground + random trees + ores
let world = [];

function generateWorld() {
  for(let y = 0; y < worldHeight; y++) {
    world[y] = [];
    for(let x = 0; x < worldWidth; x++) {
      if(y === worldHeight - 1) {
        world[y][x] = 'stone'; // bottom layer stone
      } else if (y >= worldHeight - 5) {
        world[y][x] = 'dirt'; // dirt under grass (optional)
      } else if(y === worldHeight - 6){
        world[y][x] = 'grass';
      } else {
        world[y][x] = 'air';
      }
    }
  }
  // Create simple trees randomly on grass
  for(let x = 2; x < worldWidth-2; x+=5) {
    let groundY = findSurfaceY(x);
    if(groundY > 0){
      // Tree trunk (wood) 3 blocks high
      for(let h = 1; h <= 3; h++) {
        world[groundY - h][x] = 'wood';
      }
      // Leaves around top trunk
      let leafY = groundY - 4;
      for(let lx = x-1; lx <= x+1; lx++){
        for(let ly = leafY; ly <= leafY+1; ly++){
          if(ly >=0 && lx >=0 && ly < worldHeight && lx < worldWidth){
            if(world[ly][lx] === 'air') world[ly][lx] = 'leaves';
          }
        }
      }
    }
  }
  
  // Place ores randomly underground
  for(let i=0; i<30; i++) {
    let x = Math.floor(Math.random() * worldWidth);
    let y = Math.floor(worldHeight/2 + Math.random()* (worldHeight/2 - 2));
    const ores = ['diamond', 'gold', 'iron'];
    const rarityWeights = [0.1, 0.3, 0.6]; // rarities diamond rarest
    let ore = pickWeighted(ores, rarityWeights);
    world[y][x] = ore;
  }
}

// Helper weighted random picker
function pickWeighted(items, weights) {
  let total = weights.reduce((a,b) => a+b, 0);
  let r = Math.random() * total;
  for(let i=0; i<items.length; i++) {
    if(r < weights[i]) return items[i];
    r -= weights[i];
  }
  return items[items.length-1];
}

// Find surface Y coordinate for given x
function findSurfaceY(x) {
  for(let y = 0; y < worldHeight; y++) {
    if(world[y][x] !== 'air') return y - 1;
  }
  return worldHeight - 1;
}

// Player object
let player = {
  x: 5 * tileSize,
  y: 0,
  width: tileSize,
  height: tileSize * 2,
  dx: 0,
  dy: 0,
  speed: 2,
  jumping: false,
  onGround: false
};

player.y = findSurfaceY(Math.floor(player.x / tileSize)) * tileSize;

// Inventory object: holds block counts
let inventory = {};

let inventoryOpen = false;

// Controls
const keys = {};
document.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  // Inventory toggle on 'e'
  if(e.key.toLowerCase() === 'e'){
    inventoryOpen = !inventoryOpen;
    document.getElementById('inventory').style.display = inventoryOpen ? 'block' : 'none';
    updateInventoryDisplay();
  }
});
document.addEventListener('keyup', e => {
  keys[e.key.toLowerCase()] = false;
});

// Physics variables
const gravity = 0.5;
const jumpPower = -10;

// Game loop
function gameLoop(){
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

function update(){
  // Horizontal movement
  player.dx = 0;
  if(keys['a']) player.dx = -player.speed;
  if(keys['d']) player.dx = player.speed;

  // Apply horizontal movement with collision
  if(player.dx !== 0){
    let newX = player.x + player.dx;
    if(!collides(newX, player.y)){
      player.x = newX;
    }
  }

  // Jumping
  if(keys['w'] || keys[' ']){
    if(player.onGround && !player.jumping){
      player.dy = jumpPower;
      player.jumping = true;
      player.onGround = false;
    }
  }

  // Gravity
  player.dy += gravity;
  let newY = player.y + player.dy;

  // Vertical collision check
  if(player.dy > 0){ // falling
    if(!collides(player.x, newY + player.height)){
      player.y = newY;
      player.onGround = false;
    } else {
      player.y = Math.floor((player.y + player.height)/tileSize)*tileSize - player.height;
      player.dy = 0;
      player.onGround = true;
      player.jumping = false;
    }
  } else if(player.dy < 0){ // going up
    if(!collides(player.x, newY)){
      player.y = newY;
    } else {
      player.dy = 0;
    }
  }

  // Keep player in bounds horizontally
  if(player.x < 0) player.x = 0;
  if(player.x > (worldWidth * tileSize) - player.width) player.x = (worldWidth * tileSize) - player.width;
}

function collides(x, y){
  // Check collision of player's bottom-left and bottom-right corners with non-walkable blocks
  let leftBlockX = Math.floor(x / tileSize);
  let rightBlockX = Math.floor((x + player.width - 1) / tileSize);
  let blockY = Math.floor(y / tileSize);

  // If out of world bounds vertically, consider solid ground at bottom
  if(blockY >= worldHeight) return true;
  if(blockY < 0) return false;

  // Check left block collision
  if(!BLOCKS[world[blockY][leftBlockX]].walkable) return true;
  // Check right block collision
  if(!BLOCKS[world[blockY][rightBlockX]].walkable) return true;

  return false;
}

function draw(){
  // Clear
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Calculate offset so player is centered horizontally
  let offsetX = player.x - canvas.width/2 + player.width/2;
  if(offsetX < 0) offsetX = 0;
  if(offsetX > worldWidth * tileSize - canvas.width) offsetX = worldWidth * tileSize - canvas.width;

  // Draw world
  for(let y=0; y<worldHeight; y++){
    for(let x=0; x<worldWidth; x++){
      let block = world[y][x];
      let color = BLOCKS[block]?.color || '#000';
      ctx.fillStyle = color;
      let drawX = x*tileSize - offsetX;
      let drawY = y*tileSize;
      if(drawX + tileSize >= 0 && drawX <= canvas.width){
        ctx.fillRect(drawX, drawY, tileSize, tileSize);
        // Optionally draw block borders
        ctx.strokeStyle = '#444';
        ctx.strokeRect(drawX, drawY, tileSize, tileSize);
      }
    }
  }

  // Draw player
  ctx.fillStyle = 'red';
  let playerDrawX = player.x - offsetX;
  ctx.fillRect(playerDrawX, player.y, player.width, player.height);
}

// Inventory functions
function updateInventoryDisplay(){
  const container = document.getElementById('inventorySlots');
  container.innerHTML = '';
  for(let block in inventory){
    let slot = document.createElement('div');
    slot.className = 'item-slot';
    slot.textContent = `${block}: ${inventory[block]}`;
    container.appendChild(slot);
  }
}

// Init
generateWorld();
gameLoop();
</script>

</body>
</html>
